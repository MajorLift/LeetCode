{"id":939867799,"lang":"python3","lang_name":"Python3","time":"4 months, 2 weeks","timestamp":1682485213,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/939867799/","is_pending":"Not Pending","title":"Number of Good Paths","memory":"N/A","code":"class Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        n, self.vals = len(vals), vals\n        if n == 1: return 1\n\n        self.adj = [[] for _ in range(n)]\n        for u, v in edges:\n            self.adj[u].append(v)\n            self.adj[v].append(u)\n\n        cnt = defaultdict(list)\n        for i,e in enumerate(vals):\n            cnt[e].append(i)\n        ans = 0\n        for matches in cnt.values():\n            if len(matches) == 1:\n                ans += 1\n                continue\n            for a, b in combinations(matches, 2):\n                ans += self.findPath(a, b)\n        return ans\n        \n    def findPath(self, a, b) -> int:\n        def dfs(s, t, path):\n            if s == t:\n                return len(path)\n            ans = 0\n            for v in self.adj[s]:\n                if v in path \\\n                    or self.vals[v] > self.vals[a]:\n                    continue\n                path.add(v)\n                ans += dfs(v, t, path)\n            return ans\n        return dfs(a, b, set([a]))","compare_result":"11111011010000010010000001000000000000001001001110001000000100100000101000110001001000000000000000000000000000000000011000000000000000","title_slug":"number-of-good-paths","has_notes":false,"flag_type":1}
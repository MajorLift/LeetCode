{"id":942887082,"lang":"python3","lang_name":"Python3","time":"4 months, 1 week","timestamp":1682980676,"status":10,"status_display":"Accepted","runtime":"2202 ms","url":"/submissions/detail/942887082/","is_pending":"Not Pending","title":"Number of Good Paths","memory":"43.2 MB","code":"class Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        n = len(vals)\n        count = [{vals[i]: 1} for i in range(n)]\n        edges = sorted([(max(vals[u], vals[v]), u, v) for u,v in edges])\n\n        ans = n\n        uf = UnionFind(n)\n        for w, u, v in edges:\n            root_u, root_v = map(uf.find, (u, v))\n            if root_u == root_v: continue\n            # connects subtrees root_u, root_v, each guaranteed to be\n            # comprised only of nodes s.t. vals[node] <= w\n            # (edge uv is a cut for bipartite subtree root_u | root_v)\n            uf.union(u, v)\n            # combinations: cross product\n            # 0 if vals[u] < val or vals[v] < val\n            ans += count[root_u].get(w, 0) \\\n                    * count[root_v].get(w, 0)\n            # update number of nodes s.t. vals[node] == w \n            # contained in subtree root_u | root_v\n            count[root_u][w] = count[root_u].get(w, 0) \\\n                                + count[root_v].get(w, 0)\n            count[root_v][w] = 0\n        \n        return ans\n\nclass UnionFind:\n    def __init__(self, size):\n        self.roots = list(range(size + 1))\n\n    def find(self, x):\n        if self.roots[x] == x:\n            return x\n        self.roots[x] = self.find(self.roots[x])\n        return self.roots[x]\n\n    def union(self, x, y):\n        rootX, rootY = map(self.find, (x, y))\n        if rootX == rootY: return\n        self.roots[rootY] = rootX\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-good-paths","has_notes":false,"flag_type":1}
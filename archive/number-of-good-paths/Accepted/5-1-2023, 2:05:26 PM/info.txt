{"id":942860422,"lang":"python3","lang_name":"Python3","time":"4 months, 1 week","timestamp":1682975126,"status":10,"status_display":"Accepted","runtime":"3595 ms","url":"/submissions/detail/942860422/","is_pending":"Not Pending","title":"Number of Good Paths","memory":"44.7 MB","code":"class Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        n = len(vals)\n        count = [Counter({vals[i]: 1}) for i in range(n)]\n        edges = sorted([(max(vals[u], vals[v]), u, v) for u,v in edges])\n        ans = n\n        uf = UnionFind(n)\n        for val, u, v in edges:\n            root_u, root_v = map(uf.find, (u, v))\n            if root_u == root_v: continue\n            ans += count[root_u][val] * count[root_v][val]\n            uf.union(u, v)\n            count[root_u] = Counter({val: count[root_u][val] + count[root_v][val]})\n            count[root_v] = Counter({val: 0})\n        return ans\n\nclass UnionFind:\n    def __init__(self, size):\n        self.roots = list(range(size + 1))\n\n    def find(self, x):\n        if self.roots[x] == x:\n            return x\n        self.roots[x] = self.find(self.roots[x])\n        return self.roots[x]\n\n    def union(self, x, y):\n        rootX, rootY = map(self.find, (x, y))\n        if rootX == rootY:\n            return\n        self.roots[rootY] = rootX\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-good-paths","has_notes":false,"flag_type":1}
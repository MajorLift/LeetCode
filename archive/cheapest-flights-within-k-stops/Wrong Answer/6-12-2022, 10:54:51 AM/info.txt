{"id":720624802,"lang":"python3","lang_name":"Python3","time":"1 year, 3 months","timestamp":1655056491,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/720624802/","is_pending":"Not Pending","title":"Cheapest Flights Within K Stops","memory":"N/A","code":"class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        # build adjacency list from flights\n        graph = [[] for _ in range(n)]\n        for source, target, cost in flights:\n            graph[source].append((target, cost))\n        \n        # bellman-ford with optimization\n        # relax edges v-1 times\n        dist = [(math.inf, 0) if i != src else (0, 0) for i in range(n)]\n        queue = deque([src])\n        # if relaxed and not in queue, add to queue\n        while queue:\n            print(dist)\n            v = queue.popleft()\n            for u, cost_u in graph[v]:\n                if dist[v][0] + cost_u < dist[u][0]:\n                    dist[u] = (dist[v][0] + cost_u, dist[v][1] + 1)\n                    if u not in queue and dist[u][1] <= k:\n                        queue.append(u)\n        \n        # negative cycle discovery\n        # for _ in range(n - 1):\n        \n        # return found shortest path if it has length leq k\n        return dist[dst][0]","compare_result":"111010010100100111111111111110110101101011111110011","title_slug":"cheapest-flights-within-k-stops","has_notes":false,"flag_type":1}
{"id":884888007,"lang":"python3","lang_name":"Python3","time":"7 months, 2 weeks","timestamp":1674633810,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/884888007/","is_pending":"Not Pending","title":"Swim in Rising Water","memory":"N/A","code":"class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        mst = UnionFind()\n        for _, i, j in sorted([(grid[i][j], i, j) for i in range(n) for j in range(n)]):\n            if mst.connected((0, 0), (n - 1, n - 1)):\n                break\n            min_w = +math.inf\n            min_neighbor = (0, 0)\n            for x, y in ((i - 1, j), (i + 1 , j), (i, j - 1), (i, j + 1)):\n                if 0 <= x < n and 0 <= y < n and not mst.connected((i, j), (x, y)) and grid[x][y] < min_w:\n                    min_w = grid[x][y]\n                    min_neighbor = (x, y)\n            mst.union((i, j), min_neighbor)\n        return max(grid[r][c] for (r, c) in mst.roots.keys())\n\nclass UnionFind:\n    def __init__(self):\n        self.roots = dict()\n    \n    def find(self, x):\n        if x not in self.roots:\n            return None\n        if self.roots[x] == x:\n            return x\n        self.roots[x] = self.find(self.roots[x])\n        return self.roots[x]\n\n    def union(self, x, y):\n        if x not in self.roots:\n            self.roots[x] = x\n        if y not in self.roots:\n            self.roots[y] = y\n        rootX, rootY = self.find(x), self.find(y)\n        if rootX != rootY:\n            self.roots[rootX] = rootY\n    \n    def connected(self, x, y):\n        return x in self.roots and y in self.roots and self.find(x) == self.find(y)\n","compare_result":"1111111111000000100100000000010010000000010","title_slug":"swim-in-rising-water","has_notes":false,"flag_type":1}
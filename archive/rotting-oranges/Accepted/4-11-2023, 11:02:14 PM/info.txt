{"id":932318015,"lang":"python3","lang_name":"Python3","time":"5Â months","timestamp":1681279334,"status":10,"status_display":"Accepted","runtime":"62 ms","url":"/submissions/detail/932318015/","is_pending":"Not Pending","title":"Rotting Oranges","memory":"13.9 MB","code":"class Solution:\n    def orangesRotting(self, grid: List[List[int]]):\n        DIRECTIONS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        m, n = len(grid), len(grid[0])\n        # 0b00: unmarked fresh, 0b01: marked fresh, 0b10: rotten\n        fresh = set()\n        for i, j in product(range(m), range(n)):\n            if grid[i][j] == 1:\n                fresh.add((i, j))\n                grid[i][j] = 0\n        minutes = 0\n        while fresh:    # break if no fresh oranges are left\n            # mark cells adjacent to rotten oranges\n            marked = set()\n            for i, j in fresh:\n                for direction in DIRECTIONS:\n                    x, y = map(sum, zip((i, j), direction))\n                    if 0 <= x < m and 0 <= y < n:\n                        grid[i][j] |= grid[x][y] >> 1\n                if grid[i][j] & 1:\n                    marked.add((i, j))\n            # update marked cells to rotten\n            for i, j in marked:\n                grid[i][j] <<= grid[i][j] & 1\n                # grid[i][j] &= 0b11    # and mask unnecessary\n                fresh.remove((i, j))\n            # break if state is unchanged from previous minute\n            if not marked:\n                return -1\n            minutes += 1\n        return minutes","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"rotting-oranges","has_notes":false,"flag_type":1}
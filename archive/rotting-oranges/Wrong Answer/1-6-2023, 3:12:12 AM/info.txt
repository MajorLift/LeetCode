{"id":872590363,"lang":"python3","lang_name":"Python3","time":"8 months, 1 week","timestamp":1673003532,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/872590363/","is_pending":"Not Pending","title":"Rotting Oranges","memory":"N/A","code":"class Solution:\n    def orangesRotting(self, grid: List[List[int]]):\n        m, n = len(grid), len(grid[0])\n        fresh = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n        rotten = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n        if not fresh: \n            return 0\n        if not rotten:\n            return -1\n        \n        def dfs(r, c, thread, clock = 0):\n            print(thread, (r, c), clock)\n            # print(grid)\n            grid[r][c] = 2\n            neighbors = [(i, j) for i, j in ((r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)) \\\n                if 0 <= i < m and 0 <= j < n and grid[i][j] == 1]\n            times = [dfs(i, j, thread, clock + 1) for i, j in neighbors]\n            return max(times or [clock])\n\n        times = [dfs(i, j, thread) for thread, (i, j) in enumerate(rotten)]\n        # print(times)\n        fresh = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n        if len(fresh) == 0:\n            return max(times)\n        else:\n            return -1\n","compare_result":"111111111111111011111111111111111111111111111111110111110111011001111111101110101011111010100110101010001011001010001110010000111101010101110001100000001011110000011000001110100001110111010100111000110010010000000000110100100100110100000001000100011001000101100111011001001100000000100100101100101000010101","title_slug":"rotting-oranges","has_notes":false,"flag_type":1}
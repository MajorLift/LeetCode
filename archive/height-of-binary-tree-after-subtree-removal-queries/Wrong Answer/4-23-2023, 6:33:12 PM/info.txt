{"id":938698369,"lang":"python3","lang_name":"Python3","time":"4 months, 3 weeks","timestamp":1682299992,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/938698369/","is_pending":"Not Pending","title":"Height of Binary Tree After Subtree Removal Queries","memory":"N/A","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        m = len(queries)\n        self.state = defaultdict(lambda: [0, 0, [1]])    # depth, height, path\n        self.state[1] = [0, 0, [1]]\n        self.dfs(root)\n        # print(self.state)\n        answer = []\n        for query in queries:\n            temp = {**self.state}\n            _, height, path = temp[query]\n            for node in path:\n                temp[node][1] -= height + 1\n            answer.append(sorted(temp.items(), key=lambda x: x[1][0] + x[1][1], reverse=True)[0][0])\n        return answer\n        \n    def dfs(self, node):\n        if not node or (not node.left and not node.right):\n            return 0\n        depth, height, path = self.state[node.val]\n        if node.left:\n            self.state[node.left.val] = [depth + 1, self.dfs(node.left), path + [node.left.val]]\n        if node.right:\n            self.state[node.right.val] = [depth + 1, self.dfs(node.right), path + [node.right.val]]\n        new_height = 1 + max(self.dfs(node.left), self.dfs(node.right))\n        self.state[node.val][1] = new_height\n        return new_height","compare_result":"0000000010000000000000000000000000000000","title_slug":"height-of-binary-tree-after-subtree-removal-queries","has_notes":false,"flag_type":1}
{"id":713293270,"lang":"python3","lang_name":"Python3","time":"1 year, 3 months","timestamp":1654232599,"status":10,"status_display":"Accepted","runtime":"706 ms","url":"/submissions/detail/713293270/","is_pending":"Not Pending","title":"N-Queens II","memory":"14 MB","code":"class Solution:\n    def totalNQueens(self, n: int) -> int:\n        self.num_valid_boards = 0\n        \n        def backtrack(curr = (0, 0), \n                      queen_count = 1, \n                      search_space = [(i, j) for i in range(n) for j in range(n)]):\n            # current square where the queen has been placed\n            Qrow, Qcol = curr\n            \n            # base case: \n            # increment counter if valid board state with n queens has been reached\n            if queen_count == n:\n                self.num_valid_boards += 1\n            \n            # squares that are not under attack given the current configuration\n            valid_squares = []\n            # search space is restricted to valid squares from previous call\n            for i, j in search_space:\n                # excludes curr, and squares in its row, column, and diagonals.\n                if i != Qrow and j != Qcol and abs((i - Qrow) / (j - Qcol)) != 1:\n                    valid_squares.append((i, j))\n\n            # visited nodes at the same level of the recursive tree are marked \n            # by being excluded from the search_space stack in subsequent calls\n            while len(valid_squares):\n                backtrack(valid_squares.pop(), queen_count + 1, valid_squares)\n        \n        # explore distinct first states\n        for x in range(n):\n            backtrack((0, x))\n\n        return self.num_valid_boards","compare_result":"111111111","title_slug":"n-queens-ii","has_notes":false,"flag_type":1}
{"id":968441306,"lang":"cpp","lang_name":"C++","time":"3Â months","timestamp":1686447246,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/968441306/","is_pending":"Not Pending","title":"Minimum Interval to Include Each Query","memory":"N/A","code":"class Solution {\npublic:\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\n        int n = intervals.size(), m = queries.size();\n        vector<int> output(m, -1);\n\n        enum { Start, Query, End } PointType;\n        vector<tuple<int, int, int>> events;\n        for (int i = 0; i < n; ++i) {\n            events.push_back({Start, intervals[i][0], i});\n            events.push_back({End, intervals[i][1], i});\n        }\n        for (int i = 0; i < m; ++i) {\n            events.push_back({Query, queries[i], i});\n        }\n\n        sort(events.begin(), events.end(), \n            [&](const tuple<int, int, int>& a, const tuple<int, int, int>& b) {\n            return get<1>(a) == get<1>(b) \n                ? get<0>(a) < get<0>(b) \n                : get<1>(a) < get<1>(b);\n        });\n\n        multiset<int> sweep_line;\n        for (auto &[type, pos, idx] : events) {\n            int gap = intervals[idx][1] - intervals[idx][0] + 1;\n            if (type == Start) {\n                sweep_line.emplace(gap);\n            } else if (type == End) {\n                auto it = sweep_line.lower_bound(gap);\n                sweep_line.erase(it);\n            } else {\n                output[idx] = sweep_line.begin() == sweep_line.end() \n                    ? -1 \n                    : *sweep_line.begin();\n            }\n        }\n        return output;\n    }\n};","compare_result":"111111111111111111111111111111111000000000","title_slug":"minimum-interval-to-include-each-query","has_notes":false,"flag_type":1}
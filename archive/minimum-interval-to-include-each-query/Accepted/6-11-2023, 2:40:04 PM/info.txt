{"id":969161477,"lang":"cpp","lang_name":"C++","time":"3Â months","timestamp":1686519604,"status":10,"status_display":"Accepted","runtime":"762 ms","url":"/submissions/detail/969161477/","is_pending":"Not Pending","title":"Minimum Interval to Include Each Query","memory":"121.9 MB","code":"class Solution {\npublic:\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\n        int n = intervals.size(), m = queries.size();\n        vector<int> output(m, -1);\n\n        deque<pair<int, int>> intervals_deq(n);\n        for (int i = 0; i < n; ++i) {\n            intervals_deq.push_back(make_pair(intervals[i][0], intervals[i][1]));\n        }\n        sort(intervals_deq.begin(), intervals_deq.end());\n\n        vector<pair<int, int>> query_enum(m);\n        for (int i = 0; i < m; ++i) {\n            query_enum.push_back(make_pair(queries[i], i));\n        }\n        sort(query_enum.begin(), query_enum.end());\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\n        for (auto &[query, query_idx] : query_enum) {\n            while (!intervals_deq.empty() && intervals_deq.front().first <= query) {\n                auto &[l, r] = intervals_deq.front();\n                pq.emplace(make_pair(r - l + 1, r));\n                intervals_deq.pop_front();\n            }\n            while (!pq.empty() && pq.top().second < query) {\n                pq.pop();\n            }\n            output[query_idx] = !pq.empty() \n                ? pq.top().first \n                : -1;\n        }\n        return output;\n    }\n};","compare_result":"111111111111111111111111111111111111111111","title_slug":"minimum-interval-to-include-each-query","has_notes":true,"flag_type":1}
{"id":954900397,"lang":"cpp","lang_name":"C++","time":"3 months, 3 weeks","timestamp":1684734104,"status":10,"status_display":"Accepted","runtime":"213 ms","url":"/submissions/detail/954900397/","is_pending":"Not Pending","title":"Longest Consecutive Sequence","memory":"75.1 MB","code":"class UnionFind {\nprivate:\n    typedef vector<int> vi;\n    vi root;\n    vi groupSize;\n    int _maxGroupSize;\npublic:\n    UnionFind(int n) {\n        for (int i = 0; i < n; ++i) {\n            root.push_back(i);\n            groupSize.push_back(1);\n            _maxGroupSize = 1;\n        }\n    }\n\n    int find(int x) {\n        if (x == root[x]) return x;\n        root[x] = find(root[x]);\n        return root[x];\n    }\n\n    void merge(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX == rootY) return;\n        root[rootY] = rootX;\n        groupSize[rootX] += groupSize[rootY];\n        _maxGroupSize = max(_maxGroupSize, groupSize[rootX]);\n    }\n\n    int maxGroupSize() {\n        return _maxGroupSize;\n    }\n};\n\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        unordered_map<int, int> map;\n        int serial = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (!map.count(nums[i])) {\n                map[nums[i]] = serial++;\n            }\n        }\n        UnionFind uf = UnionFind(map.size());\n        for (auto& [k, v] : map) {\n            if (map.count(k - 1)) uf.merge(v, map[k - 1]);\n        }\n        return uf.maxGroupSize();\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-consecutive-sequence","has_notes":false,"flag_type":1}
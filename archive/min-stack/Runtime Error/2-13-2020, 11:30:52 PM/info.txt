{"id":303182405,"lang":"c","lang_name":"C","time":"3 years, 7 months","timestamp":1581665452,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/303182405/","is_pending":"Not Pending","title":"Min Stack","memory":"N/A","code":"\n\n\ntypedef struct {\n    int allocSize;\n    int* elems;\n    int currSize;\n    int* mins;\n    int minSize;\n} MinStack;\n\n/** initialize your data structure here. */\n\nMinStack* minStackCreate() {\n    int initAllocSize = 4;\n    MinStack* minStack = (MinStack*) malloc(sizeof(MinStack));\n    minStack->elems = (int*) malloc(sizeof(int) * initAllocSize);\n    minStack->currSize = 0;\n    minStack->allocSize = initAllocSize;\n    minStack->mins = (int*) malloc(sizeof(int) * initAllocSize);\n    minStack->minSize = 0;\n    return minStack;\n}\n\nint minStackGetMin(MinStack* obj) {\n    return obj->mins[obj->minSize - 1];    \n}\n\nvoid minStackPush(MinStack* obj, int x) {\n    if(obj->currSize == obj->allocSize){\n        obj->allocSize *= 2;\n        obj->elems = (int*) realloc(obj->elems, obj->allocSize);\n        obj->mins = (int*) realloc(obj->mins, obj->allocSize);\n    }\n    obj->elems[obj->currSize++] = x;\n    \n    int min = minStackGetMin(obj);\n    if(x < min){\n        obj->mins[obj->minSize++] = x;\n    }\n    else obj->mins[obj->minSize++] = min;\n}\n\nint minStackTop(MinStack* obj) {\n    return obj->elems[obj->currSize - 1];\n}\n\nvoid minStackPop(MinStack* obj) {\n    if(obj->currSize > 0){\n        --(obj->currSize);\n        --(obj->minSize);\n    }\n}\n\nvoid minStackFree(MinStack* obj) {\n    free(obj->elems);\n    free(obj->mins);\n}\n\n/**\n * Your MinStack struct will be instantiated and called as such:\n * MinStack* obj = minStackCreate();\n * minStackPush(obj, x);\n \n * minStackPop(obj);\n \n * int param_3 = minStackTop(obj);\n \n * int param_4 = minStackGetMin(obj);\n \n * minStackFree(obj);\n*/","compare_result":"000000000000000000","title_slug":"min-stack","has_notes":false,"flag_type":1}
{"id":1031037751,"lang":"python3","lang_name":"Python3","time":"2 weeks, 4 days","timestamp":1692933845,"status":10,"status_display":"Accepted","runtime":"403 ms","url":"/submissions/detail/1031037751/","is_pending":"Not Pending","title":"Walking Robot Simulation","memory":"23 MB","code":"class Solution:\n    DIRECTIONS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        self.coord = (0, 0)\n        self.dir_idx = 0\n        self.max_dist = 0\n        self.obstacles_x, self.obstacles_y = defaultdict(list), defaultdict(list)\n        for x, y in sorted(obstacles):\n            self.obstacles_x[x].append(y)\n            self.obstacles_y[y].append(x)\n        \n        for command in commands:\n            if command == -2:\n                self.dir_idx = (self.dir_idx - 1) % 4\n            elif command == -1:\n                self.dir_idx = (self.dir_idx + 1) % 4\n            else:\n                offset = map(lambda e: command * e, self.DIRECTIONS[self.dir_idx])\n                nxt_coord = tuple(map(sum, zip(offset, self.coord)))\n                self.coord = self.check_obstacles(nxt_coord)\n                print(nxt_coord, self.coord)\n                self.max_dist = max(self.max_dist, self.euclid_dist())\n            # print(command, self.coord, self.dir_idx, self.max_dist)\n        return self.max_dist\n\n    def check_obstacles(self, dst: tuple[int, int]) -> tuple[int, int]:\n        (x0, y0), (x1, y1) = self.coord, dst\n        if x0 == x1:\n            if y0 <= y1:\n                for yt in self.obstacles_x[x0]:\n                    if y0 <= yt <= y1 and not (x0 == y0 == yt == 0):\n                        return (x0, yt - 1)\n            else:\n                for yt in self.obstacles_x[x0][::-1]:\n                    if y1 <= yt <= y0 and not (x0 == y0 == yt == 0):\n                        return (x0, yt + 1)\n        if y0 == y1:\n            if x0 <= x1:\n                for xt in self.obstacles_y[y0]:\n                    if x0 <= xt <= x1 and not (x0 == y0 == xt == 0):\n                        return (xt - 1, y0)\n            else:\n                for xt in self.obstacles_y[y0][::-1]:\n                    if x1 <= xt <= x0 and not (x0 == y0 == xt == 0):\n                        return (xt + 1, y0)\n        return dst\n\n    def euclid_dist(self) -> int:\n        return sum(map(lambda x: x ** 2, self.coord))\n","compare_result":"1111111111111111111111111111111111111111111111111","title_slug":"walking-robot-simulation","has_notes":false,"flag_type":1}
{"id":941907588,"lang":"python3","lang_name":"Python3","time":"4 months, 2 weeks","timestamp":1682826344,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/941907588/","is_pending":"Not Pending","title":"Checking Existence of Edge Length Limited Paths","memory":"N/A","code":"class Solution:\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\n        edgeList.sort(key=lambda x: x[2])\n        queries.sort(key=lambda x: x[2])\n        uf = UnionFind(n)\n        answer = []\n        for p, q, limit in queries:\n            if not edgeList:\n                break\n            while edgeList and edgeList[0][2] < limit:\n                u, v, _ = edgeList.pop()\n                uf.union(u, v)\n            answer.append(uf.isConnected(p, q))\n        return answer + [False] * (len(queries) - len(answer))\n\nclass UnionFind:\n    def __init__(self, size):\n        self.roots = list(range(size))\n\n    def find(self, x):\n        if self.roots[x] == x:\n            return x\n        self.roots[x] = self.find(self.roots[x])\n        return self.roots[x]\n    \n    def union(self, x, y):\n        rootX, rootY = map(self.find, (x, y))\n        if rootX == rootY:\n            return\n        self.roots[rootY] = rootX\n\n    def isConnected(self, x, y):\n        return self.find(x) == self.find(y)","compare_result":"11000000000000000000000","title_slug":"checking-existence-of-edge-length-limited-paths","has_notes":false,"flag_type":1}
{"id":941918929,"lang":"python3","lang_name":"Python3","time":"4 months, 2 weeks","timestamp":1682827325,"status":10,"status_display":"Accepted","runtime":"2418 ms","url":"/submissions/detail/941918929/","is_pending":"Not Pending","title":"Checking Existence of Edge Length Limited Paths","memory":"62.9 MB","code":"class Solution:\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\n        edgeList.sort(key=lambda x: x[2])\n        queries = sorted(\n            [[*e, i] for i,e in enumerate(queries)], \n            key=lambda x: x[2])\n        uf = UnionFind(n)\n        answer = [False] * len(queries)\n        for p, q, limit, idx in queries:\n            while edgeList and edgeList[0][2] < limit:\n                u, v, _ = edgeList.pop(0)\n                uf.union(u, v)\n            answer[idx] = uf.isConnected(p, q)\n        return answer\n\nclass UnionFind:\n    def __init__(self, size):\n        self.roots = list(range(size))\n\n    def find(self, x):\n        if self.roots[x] == x:\n            return x\n        self.roots[x] = self.find(self.roots[x])\n        return self.roots[x]\n    \n    def union(self, x, y):\n        rootX, rootY = map(self.find, (x, y))\n        if rootX == rootY:\n            return\n        self.roots[rootY] = rootX\n\n    def isConnected(self, x, y):\n        return self.find(x) == self.find(y)","compare_result":"11111111111111111111111","title_slug":"checking-existence-of-edge-length-limited-paths","has_notes":false,"flag_type":1}
{"id":937965552,"lang":"python3","lang_name":"Python3","time":"4 months, 3 weeks","timestamp":1682180009,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/937965552/","is_pending":"Not Pending","title":"Minimum Moves to Move a Box to Their Target Location","memory":"N/A","code":"class Solution:\n    def minPushBox(self, grid: List[List[str]]) -> int:\n        self.grid, self.m, self.n = grid, len(grid), len(grid[0])\n        self.DIRECTIONS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        (xs, ys), (xb, yb), (self.xt, self.yt) = map(self.findCellType, ('S', 'B', 'T'))\n\n        visited = set([((xb, yb), (xs, ys))])\n        pq = [(self.heuristic(xb, yb), 0, (xb, yb), (xs, ys))]\n        while pq:\n            _, moves, (rb, cb), (rs, cs) = heappop(pq)\n            visited.add(((rb, cb), (rs, cs)))\n            if (rb, cb) == (self.xt, self.yt):\n                return moves\n            for d in self.DIRECTIONS:\n                ib, jb = map(sum, zip((rb, cb), d))\n                is_, js = map(sum, zip((rb, cb), map(operator.neg, d)))\n                if not self.valid(ib, jb) \\\n                    or not self.valid(is_, js) \\\n                    or not self.traversable((rs, cs), (is_, js), (rb, cb)) \\\n                    or ((ib, jb), (is_, js)) in visited:\n                    continue\n                heappush(pq, (self.heuristic(ib, jb) + moves + 1, moves + 1, (ib, jb), (is_, js)))\n        return -1\n    \n    def heuristic(self, x, y):\n        return abs(self.xt - x) + abs(self.yt - y)\n    \n    def valid(self, x, y):\n        return 0 <= x < self.m and 0 <= y < self.n \\\n            and self.grid[x][y] != '#'\n\n    def traversable(self, src, dst, box):\n        queue, visited = deque([src]), set()\n        while queue:\n            curr = queue.popleft()\n            visited.add(curr)\n            if curr == dst:\n                return True\n            for i, j in (map(sum, zip(d, curr)) for d in self.DIRECTIONS):\n                if self.valid(i, j) \\\n                    and (i, j) != box \\\n                    and (i, j) not in visited:\n                    queue.append((i, j))\n        return False\n        \n    def findCellType(self, cell_type):\n        for i, j in product(range(self.m), range(self.n)):\n            if self.grid[i][j] == cell_type:\n                return (i, j)\n","compare_result":"111111111111111000000000000000","title_slug":"minimum-moves-to-move-a-box-to-their-target-location","has_notes":false,"flag_type":1}
{"id":937957692,"lang":"python3","lang_name":"Python3","time":"4 months, 3 weeks","timestamp":1682178812,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/937957692/","is_pending":"Not Pending","title":"Minimum Moves to Move a Box to Their Target Location","memory":"N/A","code":"class Solution:\n    def minPushBox(self, grid: List[List[str]]) -> int:\n        self.grid = grid\n        self.m, self.n = len(grid), len(grid[0])\n        self.DIRECTIONS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        (xs, ys), (xb, yb), (xt, yt) = map(self.findCellType, ('S', 'B', 'T'))\n\n        dist = [[+inf] * self.n for _ in range(self.m)]\n        dist[xb][yb] = 0\n        pq = [(self.manhattanDist((xb, yb), (xt, yt)), 0, (xb, yb), (xs, ys))]\n        while pq:\n            heuristic, moves, (rb, cb), (rs, cs) = heappop(pq)\n            if (rb, cb) == (xt, yt):\n                break\n            for d in self.DIRECTIONS:\n                ib, jb = map(sum, zip((rb, cb), d))\n                is_, js = map(sum, zip((rb, cb), map(operator.neg, d)))\n                if not self.valid(ib, jb) \\\n                    or not self.valid(is_, js) \\\n                    or not self.traversable((rs, cs), (is_, js), (rb, cb)):\n                    continue\n                if moves + 1 < dist[ib][jb]:\n                    dist[ib][jb] = moves + 1\n                heappush(\n                    pq, \n                    (\n                        self.manhattanDist((ib, jb), (xt, yt)), \n                        moves + 1, \n                        (ib, jb), \n                        (rb, cb)\n                    )\n                )\n        return dist[xt][yt] if dist[xt][yt] < +inf else -1\n    \n    def manhattanDist(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    \n    def valid(self, x, y):\n        return 0 <= x < self.m and 0 <= y < self.n \\\n            and self.grid[x][y] != '#'\n\n    def traversable(self, src, dst, box):\n        queue, visited = deque([src]), set()\n        while queue:\n            curr = queue.popleft()\n            if curr == dst:\n                return True\n            for i, j in (map(sum, zip(d, curr)) for d in self.DIRECTIONS):\n                if self.valid(i, j) \\\n                    and (i, j) != box \\\n                    and (i, j) not in visited:\n                    visited.add((i, j))\n                    queue.append((i, j))\n        return False\n        \n    def findCellType(self, cell_type):\n        for i, j in product(range(self.m), range(self.n)):\n            if self.grid[i][j] == cell_type:\n                return (i, j)\n","compare_result":"111111111111000000000000000000","title_slug":"minimum-moves-to-move-a-box-to-their-target-location","has_notes":false,"flag_type":1}
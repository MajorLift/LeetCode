{"id":938649954,"lang":"python3","lang_name":"Python3","time":"4 months, 3 weeks","timestamp":1682287498,"status":10,"status_display":"Accepted","runtime":"3390 ms","url":"/submissions/detail/938649954/","is_pending":"Not Pending","title":"Path With Maximum Minimum Value","memory":"20.4 MB","code":"class Solution:\n    def maximumMinimumPath(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        DIRECTIONS = ((1, 0), (0, -1), (-1, 0), (0, 1))\n        \n        hashmap = defaultdict(set)\n        for i, j in product(range(m), range(n)):\n            hashmap[grid[i][j]].add((i, j))\n        uf, visited = UnionFind(m, n), set()\n        for k in sorted(hashmap.keys(), reverse=True):\n            for x, y in hashmap[k]:\n                visited.add((x, y))\n                for i, j in (map(sum, zip((x, y), d)) for d in DIRECTIONS):\n                    if not (0 <= i < m and 0 <= j < n) \\\n                        or (i, j) not in visited:\n                        continue\n                    uf.union((x, y), (i, j))\n                if uf.connected((0, 0), (m - 1, n - 1)):\n                    return k     \n\nclass UnionFind:\n\n    def __init__(self, m, n):\n        self.root = {(i, j): (i, j) for i, j in product(range(m), range(n))}\n\n    def find(self, x):\n        if x != self.root[x]:\n            self.root[x] = self.find(self.root[x])\n        return self.root[x]\n\n    def union(self, x, y):\n        rootX, rootY = self.find(x), self.find(y)\n        self.root[rootY] = rootX\n    \n    def connected(self, x, y):\n        return self.find(x) == self.find(y)","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"path-with-maximum-minimum-value","has_notes":false,"flag_type":1}
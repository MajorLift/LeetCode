{"id":942899006,"lang":"python3","lang_name":"Python3","time":"4 months, 1 week","timestamp":1682983657,"status":10,"status_display":"Accepted","runtime":"2967 ms","url":"/submissions/detail/942899006/","is_pending":"Not Pending","title":"Path With Maximum Minimum Value","memory":"21.5 MB","code":"class Solution:\n    def maximumMinimumPath(self, grid: List[List[int]]) -> int:\n        m, n = map(len, (grid, grid[0]))\n        DIRECTIONS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n        coords = defaultdict(list)\n        for i, j in product(range(m), range(n)):\n            coords[grid[i][j]].append((i, j))\n        uf = UnionFind(m, n)\n        marked = set()\n        for val in sorted(coords.keys(), reverse=True):\n            for r, c in coords[val]:\n                marked.add((r, c))\n                for i, j in (map(sum, zip((r, c), d)) for d in DIRECTIONS):\n                    if not (0 <= i < m and 0 <= j < n) \\\n                        or (i, j) not in marked:\n                        continue\n                    uf.union((r, c), (i, j))\n            if uf.isConnected((0, 0), (m - 1, n - 1)):\n                return val\n        return min(grid[0][0], grid[-1][-1])\n        \nclass UnionFind:\n    def __init__(self, m, n):\n        self.roots = {(i, j): (i, j) for i, j in product(range(m), range(n))}\n    \n    def find(self, x):\n        if self.roots[x] != x:\n            self.roots[x] = self.find(self.roots[x])\n        return self.roots[x]\n\n    def union(self, x, y):\n        rootX, rootY = map(self.find, (x, y))\n        if rootX != rootY:\n            self.roots[rootY] = rootX\n\n    def isConnected(self, x, y):\n        return self.find(x) == self.find(y)\n        \n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"path-with-maximum-minimum-value","has_notes":false,"flag_type":1}
{"id":887069867,"lang":"python3","lang_name":"Python3","time":"7Â months, 2Â weeks","timestamp":1674942017,"status":10,"status_display":"Accepted","runtime":"55 ms","url":"/submissions/detail/887069867/","is_pending":"Not Pending","title":"Shortest Path in a Grid with Obstacles Elimination","memory":"14.1 MB","code":"class Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        source, target = (0, 0), (m - 1, n - 1)\n\n        def manhattan_dist_to_target(r, c):\n            return sum(target) - sum((r, c))\n      \n        dist = [[(+math.inf, +math.inf) for _ in range(n)] for _ in range(m)]\n        dist[0][0] = (0, 0)\n        pq = [(0, 0, source)]\n        while pq:\n            steps, removals, (r, c) = heappop(pq)\n            if (r, c) == target:\n                break\n            if k - removals >= steps + manhattan_dist_to_target(r, c):\n                return steps + manhattan_dist_to_target(r, c)\n\n            for i, j in (r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1):\n                if not (0 <= i < m and 0 <= j < n):\n                    continue\n\n                min_steps_next, min_removals_next = dist[i][j]\n                steps_next, removals_next = steps + 1, removals + grid[i][j]\n\n                if (steps_next < min_steps_next\n                    or (min_steps_next <= steps_next < +math.inf and removals_next < min_removals_next)):\n                    dist[i][j] = (steps_next, removals_next)\n                    if removals_next <= k:\n                        heappush(pq, (steps_next, removals_next, (i, j)))\n\n        min_steps_to_target = dist[-1][-1][0]\n        return min_steps_to_target if min_steps_to_target < +math.inf else -1","compare_result":"11111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-in-a-grid-with-obstacles-elimination","has_notes":false,"flag_type":1}
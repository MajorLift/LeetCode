{"id":887056868,"lang":"python3","lang_name":"Python3","time":"7Â months, 2Â weeks","timestamp":1674939704,"status":10,"status_display":"Accepted","runtime":"60 ms","url":"/submissions/detail/887056868/","is_pending":"Not Pending","title":"Shortest Path in a Grid with Obstacles Elimination","memory":"14 MB","code":"class Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        source, target = (0, 0), (m - 1, n - 1)\n\n        def manhattan_dist_to_target(r, c):\n            return sum(target) - sum((r, c))\n      \n        dist = [[(+math.inf, +math.inf) for _ in range(n)] for _ in range(m)]\n        dist[0][0] = (0, 0)\n        pq = [(0, 0, source)]\n        while pq:\n            steps, removals, (r, c) = heappop(pq)\n            if (r, c) == target:\n                break\n            if k - removals >= steps + manhattan_dist_to_target(r, c):\n                return steps + manhattan_dist_to_target(r, c)\n\n            for i, j in (r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1):\n                if not (0 <= i < m and 0 <= j < n):\n                    continue\n                min_steps_next, min_removals_next = dist[i][j]\n                if removals + grid[i][j] <= k and \\\n                    (steps + 1 < min_steps_next or \\\n                    (min_steps_next <= steps + 1 < +math.inf and removals + grid[i][j] < min_removals_next)):\n                    dist[i][j] = (steps + 1, removals + grid[i][j])\n                    heappush(pq, (steps + 1, removals + grid[i][j], (i, j)))\n\n        return dist[-1][-1][0] if dist[-1][-1][0] < +math.inf else -1","compare_result":"11111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-in-a-grid-with-obstacles-elimination","has_notes":false,"flag_type":1}
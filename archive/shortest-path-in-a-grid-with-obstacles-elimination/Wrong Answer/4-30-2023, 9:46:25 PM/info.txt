{"id":942417074,"lang":"python3","lang_name":"Python3","time":"4 months, 2 weeks","timestamp":1682916385,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/942417074/","is_pending":"Not Pending","title":"Shortest Path in a Grid with Obstacles Elimination","memory":"N/A","code":"class Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        m, n = map(len, (grid, grid[0]))\n        self.m, self.n = m, n\n        DIRECTIONS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        SRC, DST = (0, 0), (m - 1, n - 1)\n        dist = [[+inf] * n for _ in range(m)]\n        dist[0][0] = 0\n        pq = [(self.manhattan(*SRC), k, SRC)]\n        while pq:\n            heuristic, quota, (r, c) = heappop(pq)\n            if heuristic <= quota:\n                return dist[r][c] + heuristic\n            if (r, c) == DST:\n                break\n            for i, j in (map(sum, zip((r, c), d)) for d in DIRECTIONS):\n                if not (0 <= i < m and 0 <= j < n):\n                    continue\n                if dist[r][c] + 1 < dist[i][j] and quota - grid[i][j] >= 0:\n                    dist[i][j] = dist[r][c] + 1\n                    heappush(pq, (self.manhattan(i, j), quota - grid[i][j], (i, j)))\n\n        return dist[-1][-1] if dist[-1][-1] < +inf else -1            \n\n    def manhattan(self, x, y):\n        return abs(self.m - 1 - x) + abs(self.n - 1 - y)","compare_result":"11111111111111111111110000111111111111111111110010111","title_slug":"shortest-path-in-a-grid-with-obstacles-elimination","has_notes":false,"flag_type":1}
{"id":880853023,"lang":"javascript","lang_name":"JavaScript","time":"7 months, 3 weeks","timestamp":1674084150,"status":10,"status_display":"Accepted","runtime":"103 ms","url":"/submissions/detail/880853023/","is_pending":"Not Pending","title":"Word Ladder II","memory":"47.2 MB","code":"/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {string[][]}\n */\nvar findLadders = function(beginWord, endWord, wordList) {\n    wordList.push(beginWord)\n    const words = new Set(wordList)\n    if (!words.has(endWord)) return []\n    \n    const adj = wordList.reduce((acc, curr) => {\n        for (let i = 0; i < beginWord.length; ++i) {\n            const pattern = curr.slice(0, i) + \"*\" + curr.slice(i + 1)\n            acc[pattern] = (acc[pattern] ?? []).concat(curr)\n        }\n        return acc\n    }, {})\n    const tree = {}\n    const dist = wordList.reduce((acc, curr) => {\n        acc[curr] = curr !== endWord ? Number.POSITIVE_INFINITY : 0\n        return acc\n    }, {})\n    \n    let level = 0\n    let flag = false\n    const queue = [endWord]\n    while (queue.length) {\n        level++\n        const next_queue = []\n        while (queue.length) {\n            const word = queue.shift()\n            if (word === beginWord) {\n                flag = true\n                continue\n            }\n            for (let i = 0; i < beginWord.length; ++i) {\n                const pattern = word.slice(0, i) + \"*\" + word.slice(i + 1)\n                for (const prev of (adj[pattern] ?? [])) {\n                    if ((!tree[prev] || !tree[prev].has(word)) && level + 1 <= dist[prev]) {\n                        dist[prev] = level + 1\n                        if (!tree[prev]) tree[prev] = new Set([word])\n                        else tree[prev].add(word)\n                        next_queue.push(prev)\n                    }\n                }\n            }\n        }\n        if (flag) break\n        queue.push(...next_queue)\n    }\n\n    const output = []\n    const stack = [[beginWord]]\n    while (stack.length) {\n        const path = stack.pop()\n        const word = path[path.length - 1]\n        if (word === endWord) {\n            output.push(path)\n            continue\n        }\n        for (const next_word of (tree[word] ?? [])) stack.push(path.concat(next_word))\n    }\n    return output\n};","compare_result":"111111111111111111111111111111111111","title_slug":"word-ladder-ii","has_notes":false,"flag_type":1}